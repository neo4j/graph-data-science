[[migration-guide]]
= Migration Guide

ifdef::env-docs[]
[abstract]
--
This section explains how to migrate from the Neo4j Graph Algorithms library to the Neo4j Graph Data Science library.
--
endif::env-docs[]


// This section should cover these aspects:
//general concepts, ideally with some examples:
//- explicit creation >> implicit creation (named graphs >> anonymous graphs)
//- {node,relationship}Projections
//- no more (global) direction --> projection
//-- how to replace BOTH with two projections
//- no more global deduplication --> projection/aggregation
//-- SKIP -> SINGLE
//- take notes from api-overview.adoc
//-- move api-overview into public docs?
//
//procedure namespace changes
//- algo.* -> gds.*
//- explicit write mode
//- memrec -> estimate
//-- no more algo.memrec
//- labs algos: algo.* -> gds.alpha.*
//- beta algos: algo.beta.* -> gds.beta.*
//
//call syntax changes
//- always <algo>(graphNameOrConfig, configOrNothing)
//-- e.g. pageRank
//-- e.g. shortestPath
//
//config changes
//- no more `write`, `graph`, `direction`, `batchSize`, `undirected`, `sort` parameters
//- `iterations` -> `maxIterations`
//
//output changes
//- always return `configuration`
//-- for some procs, a value has moved, e.g. pageRank
//- community stats always in a map (percentiles, â€¦)
//- consistent naming of e.g. `communityId`
//-- labelPropagation: labelId -> communityId
//- loadMillis -> createMillis
//
//installation changes?
//- unrestricted_procedures: algo.* -> gds.*


GDS refers to the Graph Data Science library.
GA refers to the Graph Algorithms library


== Syntax


=== Graph operations

.Loading a named graph in the default way:
[opts=header,cols="1a,1a"]
|===
| GA | GDS
|
[source, cypher]
----
CALL algo.graph.load(
  'myGraph',
  'MyLabel',
  'MY_RELATIONSHIP_TYPE'
)
----
|
[source, cypher]
----
CALL gds.graph.create(
  'myGraph',
  'MyLabel',
  'MY_RELATIONSHIP_TYPE'
)
----
|
[source, cypher]
----
CALL algo.graph.load(
  'myGraph',
  'MyLabel',
  'MY_RELATIONSHIP_TYPE',
  {
    concurrency: 4,
    graph: 'huge',
    direction: 'INCOMING'
  }
)
----
|
[source, cypher]
----
CALL gds.graph.create(
  'myGraph',
  'MyLabel',
  {
    MY_RELATIONSHIP_TYPE: {
      projection: 'REVERSE'
    }
  },
  {
    readConcurrency: 4
  }
)
----
|===

.Estimating the memory requirements of loading a named graph:
[opts=header,cols="1a,1a"]
|===
|GA | GDS
|
[source, cypher]
----
CALL algo.memrec(
  'MyLabel',
  'MY_RELATIONSHIP_TYPE',
  'graph.load'
)
----
|
[source, cypher]
----
CALL gds.graph.create.estimate(
  'MyLabel',
  'MY_RELATIONSHIP_TYPE'
)
----
|
[source, cypher]
----
CALL algo.memrec(
  'MATCH (n:MyLabel)
   RETURN id(n) AS id',
  'MATCH (s)-[r:MY_RELATIONSHIP_TYPE]->(t)
   RETURN id(s) AS source, id(t) AS target',
  'graph.load',
  {
    graph: 'cypher'
  }
)
----
|
[source, cypher]
----
CALL gds.graph.create.cypher.estimate(
  'MATCH (n:MyLabel)
   RETURN id(n) AS id',
  'MATCH (s)-[r:MY_RELATIONSHIP_TYPE]->(t)
   RETURN id(s) AS source, id(t) AS target'
)
----
|===

.Loading a named graph using Cypher queries:
[opts=header,cols="1a,1a"]
|===
|GA | GDS
|
[source, cypher]
----
CALL algo.graph.load(
  'myGraph',
  'MATCH (n:MyLabel)
   RETURN id(n) AS id',
  'MATCH (s)-[r:MY_RELATIONSHIP_TYPE]->(t)
   RETURN id(s) AS source, id(t) AS target',
  {
    graph: 'cypher'
  }
)
----
|
[source, cypher]
----
CALL gds.graph.create.cypher(
  'myGraph',
  'MATCH (n:MyLabel)
   RETURN id(n) AS id',
  'MATCH (s)-[r:MY_RELATIONSHIP_TYPE]->(t)
   RETURN id(s) AS source, id(t) AS target'
)
----
|
[source, cypher]
----
CALL algo.graph.load(
  'myGraph',
  'MATCH (n:MyLabel)
   RETURN id(n) AS id',
  'MATCH (s)-[r:MY_RELATIONSHIP_TYPE]->(t)
   RETURN id(s) AS source, id(t) AS target, r.myProperty AS weight',
  {
    concurrency: 4,
    graph: 'cypher'
  }
)
----
|
[source, cypher]
----
CALL gds.graph.create.cypher(
  'myGraph',
  'MATCH (n:MyLabel)
   RETURN id(n) AS id',
  'MATCH (s)-[r:MY_RELATIONSHIP_TYPE]->(t)
   RETURN id(s) AS source, id(t) AS target, r.myProperty AS weight',
  {
    readConcurrency: 4
  }
)
----
|===


.Listing named graphs:
[opts=header,cols="1a,1a"]
|===
|GA | GDS
|
[source, cypher]
----
CALL algo.graph.list() YIELD name, nodes, relationships
----
|
[source, cypher]
----
CALL gds.graph.list() YIELD name, nodeCount, relationshipCount
----
|
[source, cypher]
----
CALL algo.graph.list() YIELD name, type
----
|
[source, cypher]
----
CALL gds.graph.list() YIELD name, nodeQuery, relationshipQuery
// the query fields will be null unless a Cypher projection was used
----
|
[source, cypher]
----
CALL algo.graph.list() YIELD name, direction
----
|
[source, cypher]
----
CALL gds.graph.list() YIELD name, relationshipProjection
----
|===

.Viewing information about a specific named graph:
[opts=header,cols="1a,1a"]
|===
|GA | GDS
|
[source, cypher]
----
CALL algo.graph.info('myGraph') YIELD type, direction
----
|
[source, cypher]
----
CALL gds.graph.list('myGraph') YIELD nodeQuery, relationshipQuery, relationshipProjection
// the query fields will be null unless a Cypher projection was used
----
|
[source, cypher]
----
CALL algo.graph.info('myGraph') YIELD exists
----
|
[source, cypher]
----
CALL gds.graph.exists('myGraph') YIELD exists
----
|===

.Removing a named graph:
[opts=header,cols="1a,1a"]
|===
|GA | GDS
|
[source, cypher]
----
CALL algo.graph.remove('myGraph')
----
|
[source, cypher]
----
CALL gds.graph.drop('myGraph')
----
|===

