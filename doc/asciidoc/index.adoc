= The Neo4j Graph Algorithms User Guide v{docs-version}
:toc: left
:experimental:
:sectid:
:sectlinks:
:toclevels: 2
:env-docs: true

ifdef::backend-html5[(C) {copyright}]
ifndef::backend-pdf[]

License: link:{common-license-page-uri}[Creative Commons 4.0]
endif::[]
ifdef::backend-pdf[]
(C) {copyright}

License: <<license, Creative Commons 4.0>>
endif::[]



[abstract]
--
This is the user guide for Neo4j Graph Algorithms version {docs-version}, authored by the Neo4j Team.
--

The guide covers the following areas:

* <<introduction>> -- An introduction to Neo4j Graph Algorithms.
* <<projected-graph-model>> -- A detailed guide to the projected graph model.
* <<yelp-example>> -- An illustration of how to use graph algorithms on a social network of friends.
* <<procedures>> -- A list of Neo4j Graph Algorithm procedures.
* <<algorithms-centrality>> -- A detailed guide to each of the centrality algorithms, including use-cases and examples.
* <<algorithms-community>> -- A detailed guide to each of the community detection algorithms, including use-cases and examples.


In addition to the above algorithms, there are a large number of experimental algorithm implementations developed as part of Neo4j Labs.
The Neo4j Labs algorithms are documented <<experimental-algorithms>>.

====
image::download_book.png[Graph Algorithms,200]

Graph Algorithms: Practical Examples in Apache Spark and Neo4j, by Mark Needham & Amy E. Hodler and published by O'Reilly Media is available now.

Download it for free at https://neo4j.com/graph-algorithms-book/[neo4j.com/graph-algorithms-book/].
====

[[introduction]]
== Introduction

[abstract]
--
This chapter provides an introduction to the available graph algorithms, and instructions for installation and use.
--

This library provides efficiently implemented, parallel versions of common graph algorithms for Neo4j 3.x, exposed as Cypher procedures.

[[introduction-algorithms]]
=== Algorithms

Graph algorithms are used to compute metrics for graphs, nodes, or relationships.

They can provide insights on relevant entities in the graph (centralities, ranking), or inherent structures like communities (community-detection, graph-partitioning, clustering).

Many graph algorithms are iterative approaches that frequently traverse the graph for the computation using random walks, breadth-first or depth-first searches, or pattern matching.

Due to the exponential growth of possible paths with increasing distance, many of the approaches also have high algorithmic complexity.

Fortunately, optimized algorithms exist that utilize certain structures of the graph, memoize already explored parts, and parallelize operations.
Whenever possible, we've applied these optimizations.

// include::algorithms-centrality.adoc[tags=header,leveloffset=3]
// 
// include::algorithms-centrality.adoc[tags=summary,leveloffset=3]
// 
// include::algorithms-community.adoc[tags=header,leveloffset=3]
// 
// include::algorithms-community.adoc[tags=summary,leveloffset=3]
// 
// include::algorithms-path-finding.adoc[tags=header,leveloffset=3]
// 
// include::algorithms-path-finding.adoc[tags=summary,leveloffset=3]
// 
// include::algorithms-similarity.adoc[tags=header,leveloffset=3]
// 
// include::algorithms-similarity.adoc[tags=summary,leveloffset=3]
// 
// include::algorithms-link-prediction.adoc[tags=header,leveloffset=3]
// 
// include::algorithms-link-prediction.adoc[tags=summary,leveloffset=3]
// 
// include::algorithms-preprocessing.adoc[tags=header,leveloffset=3]
// 
// include::algorithms-preprocessing.adoc[tags=summary,leveloffset=3]


=== Installation


==== Neo4j Desktop

If we are using the https://neo4j.com/docs/operations-manual/current/installation/neo4j-desktop/index.html[Neo4j Desktop^], the library can be installed from the 'Plugins' tab of a database.

image::neo4j-desktop.jpg[width=500]

The installer will download a copy of the graph algorithms library and place it in the 'plugins' directory of the database.
It will also add the following entry to the settings file:

----
dbms.security.procedures.unrestricted=algo.*
----


==== Neo4j Server

If we are using a standalone Neo4j Server, the library will need to be installed and configured manually.

. Download `graph-algorithms-algo-[version].jar` from https://github.com/neo4j-contrib/neo4j-graph-algorithms/releases[the matching release] and copy it into the `$NEO4J_HOME/plugins` directory.
We can work out which release to download by referring to the https://github.com/neo4j-contrib/neo4j-graph-algorithms/blob/master/versions.json[versions file^].


. Add the following to your `$NEO4J_HOME/conf/neo4j.conf` file:
+
----
dbms.security.procedures.unrestricted=algo.*
----
We need to give the library unrestricted access because the algorithms use the lower level Kernel API to read from, and to write to Neo4j.

+
. Restart Neo4j


==== Verifying installation

Once we've installed the library, to see a list of all the algorithms, run the following query:

----
CALL algo.list()
----


=== Usage

These algorithms are exposed as Neo4j procedures.
They can be called directly from Cypher in your Neo4j Browser, from cypher-shell, or from your client code.

For most algorithms there are two procedures:

* `algo.<name>` - this procedure writes results back to the graph as node-properties, and reports statistics.
* `algo.<name>.stream` - this procedure returns a stream of data.
For example, node-ids and computed values.
+
For large graphs, the streaming procedure might return millions, or even billions of results.
In this case it may be more convenient to store the results of the algorithm, and then use them with later queries.


include::system-requirements.adoc[leveloffset=2]

include::projected-graph-model.adoc[leveloffset=1]


[[yelp-example]]
== The Yelp example

[abstract]
--
This chapter introduces the Yelp Open Dataset that is used throughout to exemplify how the Neo4j Graph Algorithms work.
--

include::yelp-intro.adoc[leveloffset=1]


[[procedures]]
== Procedures

[abstract]
--
This chapter contains a reference of all the procedures in the Neo4j Graph Algorithms library.
--


[[table-proc]]
[opts=header,cols="1m,5a"]
|===
| Name                                                                		| Description
| <<algorithms-betweenness-centrality-syntax, algo.betweenness>>                | Betweenness centrality algorithm writing results back to the graph.
| <<algorithms-betweenness-centrality-syntax, algo.betweenness.stream>>         | Betweenness centrality algorithm streaming results back to the user.
| <<algorithms-betweenness-centrality-syntax, <algo.betweenness.sampled>>       | Approximate betweenness centrality algorithm writing results back to the graph.
| <<algorithms-betweenness-centrality-syntax, algo.betweenness.sampled.stream>> | Approximate betweenness centrality algorithm streaming results to the user.
| <<algorithms-closeness-centrality-syntax, algo.closeness>>                    | Closeness centrality algorithm writing results back to the graph.
| <<algorithms-closeness-centrality-syntax, algo.closeness.stream>>             | Closeness centrality algorithm streaming results back to the user.
| <<algorithms-degree-syntax, algo.degree>>                                     | Degree centrality algorithm writing results back to the graph.
| <<algorithms-degree-syntax, algo.degree.stream>>                              | Degree centrality algorithm streaming results back to the user.
| <<named-graph, algo.graph.load>>                                              | Procedure for pre-loading a graph and giving it a name.
| <<named-graph, algo.graph.remove>>                                            | Procedure for unloading a pre-loaded graph.
| <<named-graph, algo.graph.info>>                                              | Procedure to compute statistics about a pre-loaded graph.
| <<algorithms-label-propagation-syntax, algo.labelPropagation>>                | Label propagation algorithm writing results back to the graph.
| <<algorithms-label-propagation-syntax, algo.labelPropagation.stream>>         | Label propagation algorithm streaming results back to the user.
| <<algorithms-louvain-syntax, algo.louvain>>                                   | Louvain algorithm writing results back to the graph.
| <<algorithms-louvain-syntax, algo.louvain.stream>>                            | Louvain algorithm streaming results back to the user.
| <<algorithms-pagerank-syntax, algo.pageRank>>                                 | Page rank algorithm writing results back to the graph.
| <<algorithms-pagerank-syntax, algo.pageRank.stream>>                          | Page rank algorithm streaming results back to the user.
| <<algorithms-connected-components-syntax, algo.unionfind>>                    | Union find algorithm writing results back to the graph.
| <<algorithms-connected-components-syntax, algo.unionfind.stream>>             | Union find algorithm streaming results back to the user.
|===


include::algorithms.adoc[leveloffset=1]

[[experimental-procedures]]
== Experimental Procedures

[abstract]
--
This chapter contains a reference of all the experimental procedures in the Neo4j Graph Algorithms library.
--
[[table-experimental]]
[separator=Â¦,opts=header,cols="1m,5m,1m"]
|===
include::csv/experimental-procedures.csv[]
|===

include::experimental-index.adoc[leveloffset=1]


// ifndef::env-docs[]
// == Implementers section
// 
// include::algo-procedures-api.adoc[leveloffset=2]
// 
// // include::developer-api.adoc[leveloffset=2]
// 
// include::implementers.adoc[leveloffset=2]
// 
// :implementation:
// 
// 
// === PageRank
// 
// include::pagerank.adoc[leveloffset=2,tags=implementation]
// 
// 
// === Betweenness Centrality
// 
// include::betweenness-centrality.adoc[leveloffset=2,tags=implementation]
// 
// 
// === Closeness Centrality
// 
// include::closeness-centrality.adoc[leveloffset=2,tags=implementation]
// 
// 
// === Harmonic Centrality
// 
// include::harmonic-centrality.adoc[leveloffset=2,tags=implementation]
// 
// 
// === Minimum Weight Spanning Tree
// 
// include::minimum-weight-spanning-tree.adoc[leveloffset=2,tags=implementation]
// 
// 
// === Single Shortest Path
// 
// include::single-shortest-path.adoc[leveloffset=2,tags=implementation]
// 
// 
// === A*
// 
// include::astar.adoc[leveloffset=2,tags=implementation]
// 
// 
// === Yen's K-Shortest Paths algorithm
// 
// include::yens-k-shortest-paths.adoc[leveloffset=2,tags=implementation]
// 
// 
// === All Pairs Shortest Path
// 
// include::all-pairs-shortest-path.adoc[leveloffset=2,tags=implementation]
// 
// 
// === Triangle Count
// 
// include::triangleCount.adoc[leveloffset=2,tags=implementation]
// 
// 
// === Label Propagation
// 
// include::label-propagation.adoc[leveloffset=2,tags=implementation]
// 
// 
// === Louvain
// 
// include::louvain.adoc[leveloffset=2,tags=implementation]
// 
// 
// === Weakly Connected Components
// 
// include::connected-components.adoc[leveloffset=2,tags=implementation]
// 
// 
// === Strongly Connected Components
// 
// include::strongly-connected-components.adoc[leveloffset=2,tags=implementation]
// 
// endif::env-docs[]
// 
// ifdef::backend-html5[]
// ++++
// <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.10.13/css/jquery.dataTables.min.css">
// <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
// <script src="https://cdn.datatables.net/1.10.13/js/jquery.dataTables.min.js"></script>
// <script>
// $(document).ready(function() {
//     $('#table-all').DataTable();
// } );
// </script>
// ++++
// endif::[]
