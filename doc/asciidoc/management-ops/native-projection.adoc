[[native-projection]]
// tag::header[]
= Native projection
// end::header[]

[abstract]
--
This chapter explains native projections in the Neo4j Graph Data Science library.
--

A native projection allows us to project a graph from Neo4j into an in-memory graph.
The projected graph can be described in terms of node labels, relationship types and properties.
Node labels and node properties are projected using <<native-projection-syntax-node-projections>>.
Relationship types and relationship properties are projected using <<native-projection-syntax-relationship-projections>>.

The main benefit of native projections is the performance when creating a graph projection.
In contrast, a <<cypher-projection>> is more flexible from the declaration point of view, but less performant.
In most cases it is possible to structure your Neo4j databases in a way that native projections can be used.

This section includes:

* <<native-projection-syntax>>
* <<native-projection-syntax-node-projections>>
* <<native-projection-syntax-relationship-projections>>


[[native-projection-syntax]]
== Syntax

A native projection takes three mandatory arguments: `graphName`, `nodeProjection`, `relationshipProjection`.
In addition, the optional `configuration` parameter allows us to further configure graph creation.

[source,cypher]
----
CALL gds.graph.create(
    graphName: string,
    nodeProjection: string or map,
    relationshipProjection: string or map,
    configuration: map
)
----

.Parameters
[opts="header",cols="1,1,1"]
|===
| Name                   | Optional | Description
| graphName              | no       | The name under which the graph is stored in the catalog.
| nodeProjection         | no       | One or more <<native-projection-syntax-node-projections, node projections>>.
| relationshipProjection | no       | One or more <<native-projection-syntax-relationship-projections, relationship projections>>.
| configuration          | yes      | Additional parameters to configure the Native projection.
|===

.Configuration
[opts="header",cols="1,1,1,4"]
|===
| Name                   | Type    | Default        | Description
| concurrency            | int     | available CPUs | The number of concurrent threads used for creating the graph.
|===


[[native-projection-syntax-node-projections]]
== Node projections

A node projection defines how a specific subset of Neo4j nodes is projected into the in-memory graph.

The following map-like syntax shows the general way of defining node projections:

[source]
----
{
    <node-label-1>: {
        label: <neo-label>,
        properties: <node-property-mappings>
    },
    <node-label-2>: {
        label: <neo-label>,
        properties: <node-property-mappings>
    },
    // ...
    <node-label-n>: {
        label: <neo-label>,
        properties: <node-property-mappings>
    }
}
----

* `node-label` denotes the node label used in the projected graph
* `neo-label` denotes the name of the node label in the Neo4j graph
** The label must exist in the Neo4j database
** `neo-label` defaults to `node-label`
* `node-property-mappings` denotes a set of mappings between Neo4j and in-memory node properties

In the following example, we want to project `Person` and `Music` nodes into the in-memory graph.

.Create a graph from multiple node labels:
[source,cypher]
----
CALL gds.graph.create(
    'my-graph', {
        'Person': { label: 'Person' },
        'Music': { label: 'Music' }
    },

    '*'
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

In the above example, we are using the same labels as in the Neo4j database.
In that case we can use the following syntactic sugar.

[source,cypher]
----
// Option 1
CALL gds.graph.create( 'my-graph', 'Person | Music', '*')
YIELD graphName, nodeCount, relationshipCount, createMillis;

// Option 2
CALL gds.graph.create( 'my-graph', ['Person', 'Music'], '*')
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

To project a Neo4j node label to a custom label, we can use syntactic sugar, too.
In the following example, we want to project the Neo4j label `Person` to the element identifier `Human`.

[source,cypher]
----
CALL gds.graph.create( 'my-graph', [{Human : 'Person'}, 'Music'], '*')
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

To project all nodes in the Neo4j graph, we can use the special `*` node projection.
This node projection can not be combined with any other node projection.

[source,cypher]
----
CALL gds.graph.create('my-graph', '*', '*')
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

=== Node properties

We can load multiple node properties for each node projection using node property mappings.

The following map-like syntax shows the general way of defining node property mappings:

[source]
----
{
    <node-label-1>: {
        label: <neo-label>,
        properties: {
            <property-key-1>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>
            },
            <property-key-2>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>
            },
            // ...
            <property-key-n>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>
            },
        }
    }
}
----

* `<property-key>` denotes the name of the property in the projected graph
** `<neo-property-key>` denotes the name of the property in the Neo4j graph
*** The property key must exist in the Neo4j database
*** `<neo-property-key>` defaults to `<property-key>`
** `<numeric-value>` is used if the property does not exist for a node
*** `<numeric-value>` defaults to `NaN`

In the following example, we want to project `Person` and their properties nodes into the in-memory graph.

.Create a graph from with multiple node properties:
[source,cypher]
----
CALL gds.graph.create(
    'my-graph', {
        'Person': {
            label: 'Person',
            properties: {
                age: {
                    property: 'age',
                    defaultValue: 0
                },
                zipCode: {
                    property: 'zip',
                    defaultValue: -1
                }
            }
        }
    },

    '*'
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

If we want to load the same properties for each node label, we can use the following syntax sugar.

.Project node properties for multiple node labels:
[source,cypher]
----
CALL gds.graph.create( 'my-graph', 'Person', '*', {
        nodeProperties: ['age', {zipCode: 'zip'}]
    }
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----


[[native-projection-syntax-relationship-projections]]
== Relationship projections

// == Loading multiple relationship types and node labels
//
// Using the `algo.graph.load` procedure it is possible to specify multiple relationship types and node labels.
// The loaded graph will retain the relationship type information.
// A graph loaded with multiple relationship types supports filtering subgraphs based on these types.
// Node label information is not retained in the loaded graph.
//
// Graphs loaded with an empty relationship projection, or a Cypher relationship projection query, do not retain information about relationship types.
//
// .The following example will create the graph `my-graph` with relationships that have the type `REL_TYPE1`, `REL_TYPE2` or `REL_TYPE3`:
// [source, cypher]
// ----
// CALL algo.graph.load('my-graph', null, 'REL_TYPE1 | REL_TYPE2 | REL_TYPE3', {direction: 'OUTGOING', concurrency: 8 })
// ----
//
// Having loaded the graph with multiple relationship types we can run an algorithm on a filtered subgraph based on these types.
// To run an algorithm over a subset of the graph we specify one or more of the loaded relationship types in the `relationship` parameter for the algorithm.
// If the `relationship` parameter is empty, the whole graph is used.
//
// .The following example will run Page Rank only on relationships of type `REL_TYPE1` or `REL_TYPE2`:
// [source,cypher]
// ----
// CALL algo.pageRank(null, 'REL_TYPE1 | REL_TYPE2', {graph: 'my-graph'})
// ----
//
// The same syntax used to load multiple relationship types can also be used to load multiple labels.
//
// .The following example will load a graph `my-graph` with nodes that have either the `Person` or `Instrument` label:
// [source, cypher]
// ----
// CALL algo.graph.load('my-graph', 'Person | Instrument', null, {direction: 'OUTGOING', concurrency: 8 })
// ----
//
// Unlike multiple relationship types, the node label information is not retained in the loaded graph.
//
//
// [[deduplication-of-parallel-relationships]]
// == Deduplication of parallel relationships
//
// Named graphs offer different ways of handling multiple - so called "parallel" - relationships between a given pair of nodes.
//
//
// === Node-label and relationship-type projection
//
// By default, the Huge graph assumes that the relationship projection only contains one relationship between a pair of nodes and will simply ignore all other relationships (see `skip` below).
// In order to control the deduplication behavior we can pass the `duplicateRelationships` key in the config to decide what should happen with duplicates.
//
// `duplicateRelationships` supports the following options:
//
// * `none` - keeps all relationships between a given pair of nodes / no deduplication.
// * `skip` - keeps the first encountered relationship (and associated weight).
// * `sum` - sums the associated weights of all encountered relationships.
// * `min` - keeps the minimum weight of all encountered relationships.
// * `max` - keeps the maximum weight of all encountered relationships.
//
// Note that setting an explict deduplication strategy, other then `none` or `skip` will increase the relationship loading time.
//
// .The following query loads a graph of roads between locations keeping all the `ROAD` relationships between two `Loc` nodes.
// [source,cypher]
// ----
// CALL algo.graph.load('allRoads', 'Loc', 'ROAD', {
//   graph: 'huge',
//   relationshipWeight: 'cost',
//   duplicateRelationships: 'none'})
// ----
//
// .The following query loads a graph of roads between locations keeping only those `ROAD` relationships with the minimal cost.
// [source,cypher]
// ----
// CALL algo.graph.load('cheapestRoads', 'Loc', 'ROAD', {
//   graph: 'huge',
//   relationshipWeight: 'cost',
//   duplicateRelationships: 'sum'})
// ----
// == Loading multiple node properties
//
// It is often useful to load an in-memory graph with more than one node property.
// A typical scenario is running different weighted algorithms on the same graph, but with different node properties as weight.
//
// For the `load.graph` procedure, loading multiple node properties can be configured via the `nodeProperties` parameter.
// The parameter is configured using a map in which each key refers to a user-defined property key.
// Any algorithm that supports node properties, for example for node weights or seed values, can refer to these user-defined property keys.
//
// The value under each property key is a configuration, that is applied when loading node properties.
// In the configuration we specify the Neo4j node property to load.
//
// For the following example, let's assume that each `City` node stores two properties: the `population` of the city and an optional `stateId` that identifies the state in which the city is located.
//
// .The following query loads all cities, including the two properties, since not all cities have a `stateId`, we set the `defaultValue` to `0`
// [source,cypher]
// ----
// CALL algo.graph.load('cities', 'City', '', {
//   graph: 'huge',
//   nodeProperties: {
//     population: {
//         property: 'population'
//     },
//     seedValue: {
//         property: 'stateId',
//         defaultValue: 0
//     }
//   }
// })
// ----
//
// We can refer to the loaded properties in each algorithm that supports reading node properties.
// For a path search algorithm, one could use the `population` as node weight whereas a clustering algorithm could use the `stateId` as seed value.
//
// We can also use the <<cypher-projection, Cypher projection>> to load multiple node properties.
// Here, the specified Neo4j node property must appear in the `RETURN` clause of the node query.
// If a property is not present on a node in Neo4j, the given default value is used instead.
//
// .The following query also loads all cities including their `population` and `stateId` properties
// [source,cypher]
// ----
// CALL gds.graph.create.cypher('cities',
//   'MATCH (c:City) RETURN id(c) AS id, c.population AS population, c.stateId AS stateId',
//   'MATCH (a:City)-->(b:City) RETURN id(a) AS sourceId, id(b) AS targetId',
//   {
//     nodeProperties: {
//       population: {
//           property: 'population'
//       },
//       seedValue: {
//           property: 'stateId',
//           defaultValue: 0
//       }
//   }
// })
// ----
//
// .If we just want to refer to the Neo4j node property key, we can use the following shorthand syntax:
// [source,cypher]
// ----
// CALL algo.graph.load('cities', 'City', '', {
//   graph: 'huge',
//   nodeProperties: {
//     population: 'population',
//     seedValue: 'stateId'
//   }
// })
// ----
//
// .We can also use the `nodeProperties` parameter to load a single node property:
// [source,cypher]
// ----
// CALL algo.graph.load('cities', 'City', '', {
//   graph: 'huge',
//   nodeProperties: 'population'
// })
// ----
//
//
// == Loading multiple relationship properties
//
// Similar to node properties, the `load.graph` procedure also supports loading multiple relationship properties.
// Those can be configured via the `relationshipProperties` parameter.
//
// As for nodes, the parameter is configured using a map in which each key refers to a user-defined property key.
// In addition to the Neo4j relationship property and an optional default value, we can define an aggregation function to set the deduplication behavior and a default property value which is used for absent property values (see <<deduplication-of-parallel-relationships>>).
//
// For the following example, let's assume that each `ROAD` relationship stores two properties: the `cost` (distance) and the road `quality` (between 1 and 10).
//
// .The following query loads all roads, deduplicates parallel relationships and aggregates them by their distance and also by their quality.
// [source,cypher]
// ----
// CALL algo.graph.load('allRoads', 'Loc', 'ROAD', {
//   graph: 'huge',
//   relationshipProperties: {
//     minDistance: {
//         property: 'cost',
//         aggregation: 'MIN',
//         defaultValue: 1.0
//     },
//     maxQuality: {
//         property: 'quality',
//         aggregation: 'MAX',
//         defaultValue: 5.0
//     }
//   }
// })
// ----
//
// When executed, our `allRoads` in-memory graph stores two relationship properties: `minDistance` and `maxQuality`.
// We can access the loaded properties by specifying them in an algorithm configuration.
// Let us use `gds.alpha.shortestPath` again as an example weighted algorithm.
//
// .We first compute the shortest path using the `minDistance` property as weight to compute the path with shortest distance:
// [source,cypher]
// ----
// MATCH (start:Loc {name: 'A'}), (end:Loc {name: 'F'})
// CALL gds.alpha.shortestPath.write(
//   'allRoads',
//   {
//       startNode: start,
//       endNode: end,
//       weightProperty: 'minDistance'
//   }
// ) YIELD writeMillis, loadMillis, nodeCount, totalCost
// RETURN writeMillis, loadMillis, nodeCount, totalCost
// ----
//
// .We use the same graph, but the `maxQuality` property if we are interested in the path with the best quality:
// [source,cypher]
// ----
// MATCH (start:Loc {name: 'A'}), (end:Loc {name: 'F'})
// CALL gds.alpha.shortestPath.write(
//   'allRoads',
//   {
//       startNode: start,
//       endNode: end,
//       weightProperty: 'maxQuality'
//   }
// ) YIELD writeMillis, loadMillis, nodeCount, totalCost
// RETURN writeMillis, loadMillis, nodeCount, totalCost
// ----
//
// With the short-hand syntax for specifying property mappings we can skip the `aggregation` and `defaultWeight` parameters.
// If those are omitted, the procedure uses `SKIP` as default aggregation function and `Double.NaN` as default property value.
//
// .The following query loads the graph and allows us to refer to the `cost` property via `distance`:
// [source,cypher]
// ----
// CALL algo.graph.load('allRoads', 'Loc', 'ROAD', {
//   graph: 'huge',
//   relationshipProperties: { distance: 'cost' }
// })
// ----
//
// Note that in this particular shortest path example, using the default property value is not recommended.
//
// [NOTE]
// ====
// Loading multiple relationship properties is currently only supported for node-label and relationship-type projections.
// ====
//
// [CAUTION]
// ====
// As with relationship types, loading a lot of multiple relationship properties can have a negative impact on performace, both during load and execution time.
// It is best to only load as few properties as needed.
// ====