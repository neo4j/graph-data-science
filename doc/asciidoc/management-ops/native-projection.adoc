[[native-projection]]
// tag::header[]
= Native projection
// end::header[]

[abstract]
--
This chapter explains native projections in the Neo4j Graph Data Science library.
--

A native projection allows us to project a graph from Neo4j into an in-memory graph.
The projected graph can be described in terms of node labels, relationship types and properties.
Node labels and node properties are projected using <<native-projection-syntax-node-projections>>.
Relationship types and relationship properties are projected using <<native-projection-syntax-relationship-projections>>.

The main benefit of native projections is the performance when creating a graph projection.
In contrast, a <<cypher-projection>> is more flexible from the declaration point of view, but less performant.
In most cases it is possible to structure your Neo4j databases in a way that native projections can be used.

This section includes:

* <<native-projection-syntax>>
* <<native-projection-syntax-node-projections>>
* <<native-projection-syntax-relationship-projections>>


[[native-projection-syntax]]
== Syntax

A native projection takes three mandatory arguments: `graphName`, `nodeProjection` and `relationshipProjection`.
In addition, the optional `configuration` parameter allows us to further configure graph creation.

[source,cypher]
----
CALL gds.graph.create(
    graphName: string,
    nodeProjection: string or map,
    relationshipProjection: string or map,
    configuration: map
)
----

.Parameters
[opts="header",cols="1,1,1"]
|===
| Name                   | Optional | Description
| graphName              | no       | The name under which the graph is stored in the catalog.
| nodeProjection         | no       | One or more <<native-projection-syntax-node-projections, node projections>>.
| relationshipProjection | no       | One or more <<native-projection-syntax-relationship-projections, relationship projections>>.
| configuration          | yes      | Additional parameters to configure the native projection.
|===

.Configuration
[opts="header",cols="1,1,1,4"]
|===
| Name                   | Type                  | Default        | Description
| concurrency            | int                   | available CPUs | The number of concurrent threads used for creating the graph.
| nodeProperties         | string or list or map | empty map      |
|===


[[native-projection-syntax-node-projections]]
== Node projections

A node projection defines how a specific subset of Neo4j nodes is projected into the in-memory graph.

The following map-like syntax shows the general way of defining node projections:

[source]
----
{
    <node-label-1>: {
        label: <neo-label>,
        properties: <node-property-mappings>
    },
    <node-label-2>: {
        label: <neo-label>,
        properties: <node-property-mappings>
    },
    // ...
    <node-label-n>: {
        label: <neo-label>,
        properties: <node-property-mappings>
    }
}
----

* `node-label-i` denotes the node label used in the projected graph
** `neo-label` denotes the node label in the Neo4j graph
*** The label must exist in the Neo4j database
*** If not specified, `neo-label` defaults to `node-label-i`
** `node-property-mappings` denotes a set of mappings between Neo4j and in-memory properties

In the following example, we want to project `Person` and `City` nodes into the in-memory graph.

.Create a graph from multiple node labels:
[source,cypher]
----
CALL gds.graph.create(
    'my-graph', {
        'Person': { label: 'Person' },
        'City': { label: 'City' }
    },

    '*'
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

In the above example, we are using the same labels as in the Neo4j database.
In that case we can use the following syntactic sugar.

[source,cypher]
----
// Option 1: Node labels separated by the | symbol
CALL gds.graph.create( 'my-graph', 'Person | City', '*')
YIELD graphName, nodeCount, relationshipCount, createMillis;

// Option 2: A list of node labels
CALL gds.graph.create( 'my-graph', ['Person', 'City'], '*')
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

To project a Neo4j node label to a custom label, we can use syntactic sugar, too.
In the following example, we want to project the Neo4j label `Person` to the element identifier `Employee`.

[source,cypher]
----
CALL gds.graph.create( 'my-graph', [{Employee : 'Person'}, 'City'], '*')
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

To project all nodes in the Neo4j graph, we can use the special `*` node projection.
Note, that this node projection can not be combined with any other node projection.

[source,cypher]
----
CALL gds.graph.create('my-graph', '*', '*')
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

=== Node properties

It is often useful to load an in-memory graph with more than one node property.
A typical scenario is running different seedable algorithms on the same graph, but with different node properties as seed.
We can load multiple node properties for each node projection using node property mappings.
A node property mapping maps a user-defined property key to a property key in the Neo4j database.
Any algorithm that supports node properties can refer to these user-defined property keys.

The following map-like syntax shows the general way of defining node property mappings:

[source]
----
{
    <node-label-1>: {
        label: <neo-label>,
        properties: {
            <property-key-1>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>
            },
            <property-key-2>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>
            },
            // ...
            <property-key-n>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>
            }
        }
    }
}
----

* `property-key-i` denotes the property key in the projected graph
** `neo-property-key` denotes the property key in the Neo4j graph
*** The property key must exist in the Neo4j database
*** If not specified, `neo-property-key` defaults to `property-key-i`
** `numeric-value` is used if the property does not exist for a node
*** If not specified, `numeric-value` defaults to `NaN`

For the following example, let's assume that each `City` node stores two properties: the `population` of the city and an optional `stateId` that identifies the state in which the city is located.
We want to project both properties and project `stateId` to the custom property key `community`.

.Create a graph with multiple node properties:
[source,cypher]
----
CALL gds.graph.create(
    'my-graph', {
        'City': {
            properties: {
                community: {
                    property: 'stateId'
                },
                population: {
                    property: 'population'
                }
            }
        }
    },

    '*'
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

If we want to load the same properties for each node label, we can use the following syntactic sugar.

.Project node properties for multiple node labels:
[source,cypher]
----
CALL gds.graph.create('my-graph', 'City', '*', {
        nodeProperties: ['population', { community: 'stateId' }]
    }
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

The projected properties can be referred to by any algorithm that uses properties as input, for example, <<algorithms-label-propagation, Label Propagation>>.

[source,cypher]
----
CALL gds.labelPropagation.stream(
    'my-graph', {
        seedProperty: 'community'
    }
)
----

[[native-projection-syntax-relationship-projections]]
== Relationship projections

A relationship projection defines how a specific subset of Neo4j relationships is projected into the in-memory graph.

The following map-like syntax shows the general way of defining relationship projections:

[source]
----
{
    <relationship-type-1>: {
        type: <neo-type>,
        projection: <projection-type>,
        aggregation: <aggregation-type>,
        properties: <relationship-property-mappings>
    },
    <relationship-type-2>: {
        type: <neo-type>,
        projection: <projection-type>,
        aggregation: <aggregation-type>,
        properties: <relationship-property-mappings>
    },
    // ...
    <relationship-type-n>: {
        type: <neo-type>,
        projection: <projection-type>,
        aggregation: <aggregation-type>,
        properties: <relationship-property-mappings>
    }
}
----

* `relationship-type-i` denotes the relationship type in the projected graph
** `neo-type` denotes the relationship type in the Neo4j graph
*** The relationship type must exist in the Neo4j database
*** If not specified, `neo-type` defaults to `relationship-type-i`
** `projection-type` denotes how Neo4j relationships are represented in the projected graph.
    The following values are allowed:
*** `NATURAL`: each relationship is projected the same way as it is stored in Neo4j (default)
*** `REVERSE`: each relationship is reversed during graph projection
*** `UNDIRECTED`: each relationship is projected in both natural and reverse orientation
** `aggregation-type` denotes how parallel relationships and their properties are handled.
    The specified value is applied to all property mappings that have no aggregation specified.
    The following values are allowed:
*** `NONE`: parallel relationships are not aggregated (default)
*** `MIN`, `MAX`, `SUM`: applied to the numeric properties of parallel relationships
*** `SINGLE`: a single, arbitrary relationship out of the parallel relationships is projected
** `relationship-property-mappings` denotes a set of mappings between Neo4j and in-memory relationship properties


In the following example, we want to project `City` nodes as well as `ROAD` and `RAIL` relationships into the in-memory graph.

[source,cypher]
----
CALL gds.graph.create(
    'my-graph',
    'City',
    {
        'ROAD': {
            type: 'ROAD',
            projection: 'NATURAL'
        },
        'RAIL': {
            type: 'RAIL',
            projection: 'NATURAL'
        }
    }
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

In the above example, we are using the same relationship type as in the Neo4j database.
In that case we can use the following syntactic sugar, similar to node projections.

[source,cypher]
----
// Option 1
CALL gds.graph.create( 'my-graph', 'City', 'ROAD | RAIL')
YIELD graphName, nodeCount, relationshipCount, createMillis;

// Option 2
CALL gds.graph.create( 'my-graph', 'City', ['ROAD', 'RAIL'])
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

Projecting multiple relationship types enables algorithms to only use a subset of those.

[source,cypher]
----
// Uses `ROAD` relationships for computing Page Rank of cities
CALL gds.pageRank.stream('my-graph', { relationshipTypes: ['ROAD'] });

// Uses `RAIL` relationships for computing Page Rank of cities
CALL gds.pageRank.stream('my-graph', { relationshipTypes: ['RAIL'] });
----


=== Relationship properties

Similar to node properties, relationship projections support loading multiple relationship properties.
We can load multiple relationship properties for each relationship projection using relationship property mappings.
A relationship property mapping maps a user-defined property key to a property key in the Neo4j database.
As for nodes, the parameter is configured using a map in which each key refers to a user-defined property key.

The following map-like syntax shows the general way of defining relationship property mappings:

[source]
----
{
    <relationship-type-1>: {
        type: <neo-type>,
        projection: <projection-type>,
        aggregation: <aggregation-type>,
        properties: {
            <property-key-1>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>,
                aggregation: <aggregation-type>
            },
            <property-key-2>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>,
                aggregation: <aggregation-type>
            },
            // ...
            <property-key-n>: {
                property: <neo-property-key>,
                defaultValue: <numeric-value>,
                aggregation: <aggregation-type>
            }
        }
    }
}
----

* `property-key-i` denotes the name of the property in the projected graph
** `neo-property-key` denotes the name of the property in the Neo4j graph
*** The property key must exist in the Neo4j database
*** `neo-property-key` defaults to `property-key-i`
** `numeric-value` is used if the property does not exist for a node
*** `numeric-value` defaults to `NaN`
** `aggregation-type` denotes how properties of parallel relationships are handled.
    The specified value override the aggregation type specified for the enclosing relationship projection.
    The following values are allowed:
*** `NONE`: parallel relationships are not aggregated (default)
*** `MIN`, `MAX`, `SUM`: applied to the numeric properties of parallel relationships
*** `SINGLE`: a single, arbitrary relationship out of the parallel relationships is projected

In the following example, we want to project `City` nodes and `ROAD` relationships.
For nodes we project the `stateId` propertie

.Create a graph with multiple node and relationship properties:
[source,cypher]
----
CALL gds.graph.create(
    'my-graph', {
        'City': {
            properties: {
                community: {
                    property: 'stateId'
                }
            }
        }
    }, {
        'ROAD': {
            properties: {
                quality: {
                    property: 'condition'
                },
                distance: {
                    property: 'length'
                }
            }
        }
    }
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

We can use the following shorthand syntax to express the same projection.

[source,cypher]
----
CALL gds.graph.create(
    'my-graph', 'City', 'ROAD', {
        nodeProperties: { community: 'stateId' },
        relationshipProperties: [{ quality: 'condition' }, { distance: 'length' }]
    }
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

The projected properties can be referred to by any algorithm that uses properties as input, for example, <<algorithms-label-propagation, Label Propagation>>.

[source,cypher]
----
// Option 1: Use the road quality as relationship weight
CALL gds.labelPropagation.stream(
    'my-graph', {
        seedProperty: 'community',
        relationshipWeightProperty: 'quality'
    }
)
// Option 2: Use the distance between cities as relationship weight
CALL gds.labelPropagation.stream(
    'my-graph', {
        seedProperty: 'community',
        relationshipWeightProperty: 'distance'
    }
)
----


=== Relationship aggregations

Relationship projections offer different ways of handling multiple - so called "parallel" - relationships between a given pair of nodes.
The default is the `NONE` aggregation which keeps all parallel relationships and directly projects them into the in-memory graph.
All other aggregations project all the parallel relationships between a pair of nodes into a single relationship.

In the following example, we want to aggregate all `ROAD` relationships between two cities to a single relationship.
While doing so, we compute the maximum quality of the parallel relationships and store it on the resulting relationship.

.Create a graph with aggregated parallel relationships:
[source,cypher]
----
CALL gds.graph.create(
    'my-graph', {
        'City': {
            properties: {
                community: {
                    property: 'stateId'
                }
            }
        }
    }, {
        'ROAD': {
            properties: {
                maxQuality: {
                    property: 'condition',
                    aggregation: 'MAX',
                    defaultValue: 1.0
                }
            }
        }
    }
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

Since we have only one node projection and one relationship projection, we can use the following shorthand syntax.

[source,cypher]
----
CALL gds.graph.create(
    'my-graph', 'City', 'ROAD', {
        nodeProperties: { community: 'stateId' },
        relationshipProperties: { maxQuality: { property: 'condition', aggregation: 'MAX', defaultValue: 1.0 }}
    }
)
YIELD graphName, nodeCount, relationshipCount, createMillis;
----

As before, the projected properties can be referred to by any algorithm that uses properties as input, for example, <<algorithms-label-propagation, Label Propagation>>.

[source,cypher]
----
CALL gds.labelPropagation.stream(
    'my-graph', {
        seedProperty: 'community',
        relationshipWeightProperty: 'maxQuality'
    }
)
----